'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _utils = require('./utils');

var _updateJs = require('update-js');

var _updateJs2 = _interopRequireDefault(_updateJs);

var _lodash = require('lodash.get');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var promiseSupported = typeof Promise === 'function';

var Form = function (_ref) {
  _inherits(Form, _ref);

  function Form() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Form);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Form.__proto__ || Object.getPrototypeOf(Form)).call.apply(_ref2, [this].concat(args))), _this), _this.state = { errors: {} }, _this.validator = (0, _utils.buildFormValidator)(_this), _this._handlersCache = (0, _utils.buildHandlersCache)(), _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Form, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps() {
      if (this._nextErrors) {
        this.setState({ errors: this._nextErrors });
        this._nextErrors = null;
      }
    }
  }, {
    key: 'save',
    value: function save() {
      var _this2 = this;

      if (this.props.validateOnSave) {
        return this.ifValid(function () {
          return _this2._save();
        });
      }
      return this._save();
    }
  }, {
    key: '_save',
    value: function _save() {
      return this.props.onRequestSave(this.get(), this);
    }
  }, {
    key: '$',
    value: function $(name) {
      var _this3 = this;

      var handler = this._handlersCache.fetch(name, function () {
        return _this3.set.bind(_this3, name);
      });

      var wrapper = function wrapper(handler) {
        for (var _len2 = arguments.length, bindings = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          bindings[_key2 - 1] = arguments[_key2];
        }

        wrapper.onChange = _this3._handlersCache.fetch([name, handler].concat(bindings), function () {
          return handler.hasOwnProperty('prototype') ? handler.bind.apply(handler, [_this3].concat(bindings)) : handler;
        });

        return wrapper;
      };
      Object.defineProperty(wrapper, 'name', { value: name, enumerable: true });
      Object.assign(wrapper, {
        value: this.get(name),
        onChange: handler,
        error: this.getError(name)
      });

      return wrapper;
    }
  }, {
    key: 'input',
    value: function input(name) {
      return this.$(name);
    }
  }, {
    key: 'reset',
    value: function reset() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this._nextErrors = {};
      this.props.onChange(attrs);
    }
  }, {
    key: 'get',
    value: function get(name) {
      if (name === undefined) return this.props.attrs;

      return (0, _lodash2.default)(this.props.attrs, name.split('.'));
    }
  }, {
    key: 'set',
    value: function set(name, value) {
      if (name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && name.constructor === Object) return this._setObject(name);

      return this._setAttr(name, value);
    }
  }, {
    key: '_setObject',
    value: function _setObject(obj) {
      var _this4 = this;

      return this._set(function (attrs, errors) {
        for (var name in obj) {
          _updateJs2.default.in(attrs, name, obj[name]);
          _this4._updateErrors(errors, name, obj[name]);
        }
      });
    }
  }, {
    key: '_setAttr',
    value: function _setAttr(name, value) {
      var _this5 = this;

      return this._set(function (attrs, errors) {
        _updateJs2.default.in(attrs, name, value);
        _this5._updateErrors(errors, name, value);
      });
    }
  }, {
    key: '_updateErrors',
    value: function _updateErrors(errors, name, value) {
      if (this._shouldClearError(name)) {
        errors[name] = null;
      }

      if (this._shouldValidateOnChange()) {
        errors[name] = this.validator(name, { value: value });
      }
    }
  }, {
    key: '_set',
    value: function _set(updater) {
      var _props = this.props,
          attrs = _props.attrs,
          onChange = _props.onChange;

      var nextAttrs = _extends({}, attrs);
      var nextErrors = _extends({}, this.getErrors());
      updater(nextAttrs, nextErrors);

      this._nextErrors = nextErrors;

      if (promiseSupported) {
        return new Promise(function (resolve) {
          onChange(nextAttrs);
          setTimeout(resolve, 0);
        });
      }

      onChange(nextAttrs);
    }
  }, {
    key: '_shouldClearError',
    value: function _shouldClearError(name) {
      return this.props.clearErrorsOnChange && this.getError(name);
    }
  }, {
    key: '_shouldValidateOnChange',
    value: function _shouldValidateOnChange() {
      return this.props.validateOnChange && this.state.hadErrors;
    }
  }, {
    key: 'ifValid',
    value: function ifValid(callback) {
      var onValidationFailed = this.props.onValidationFailed;

      var errors = this.getValidationErrors();

      this.setErrors(errors, function () {
        var valid = Object.getOwnPropertyNames(errors).length === 0;

        if (valid && callback) {
          callback();
        }

        if (!valid && onValidationFailed) {
          onValidationFailed(errors, this);
        }
      });

      return errors;
    }
  }, {
    key: 'performValidation',
    value: function performValidation() {
      return this.ifValid();
    }
  }, {
    key: 'getValidationErrors',
    value: function getValidationErrors() {
      this.validator.clearErrors();
      return this.validate(this.validator);
    }
  }, {
    key: 'validate',
    value: function validate(validator) {
      for (var name in this._validations) {
        this._validate(name);
      }

      return validator.errors;
    }
  }, {
    key: '_validate',
    value: function _validate(name) {
      if (name.includes('*')) {
        this._validateEach(name);
      } else {
        this.validator(name);
      }
    }
  }, {
    key: '_validateEach',
    value: function _validateEach(name) {
      var _this6 = this;

      var match = name.match(/^([^*]+)\.\*(.+)?$/);

      var _match$slice = match.slice(1),
          _match$slice2 = _slicedToArray(_match$slice, 2),
          collectionName = _match$slice2[0],
          _match$slice2$ = _match$slice2[1],
          rest = _match$slice2$ === undefined ? '' : _match$slice2$;

      this.each(collectionName, function (_item, i) {
        _this6._validate(collectionName + '.' + i + rest);
      });
    }
  }, {
    key: 'merge',
    value: function merge(name, value) {
      var current = this.get(name) || {};

      return this.set(name, _extends({}, current, value));
    }
  }, {
    key: 'push',
    value: function push(name, value) {
      var ary = this.get(name) || [];

      return this.set(name, [].concat(_toConsumableArray(ary), [value]));
    }
  }, {
    key: 'remove',
    value: function remove(name, i) {
      var _this7 = this;

      var ary = this.get(name);

      return this._set(function (attrs, errors) {
        _updateJs2.default.in(attrs, name, [].concat(_toConsumableArray(ary.slice(0, i)), _toConsumableArray(ary.slice(i + 1))));
        _this7._updateErrors(errors, name + '.' + i, null);
      });
    }
  }, {
    key: 'each',
    value: function each(path, iteratee) {
      var value = this.get(path) || [];

      return value.forEach(iteratee);
    }
  }, {
    key: 'map',
    value: function map(path, iteratee) {
      var value = this.get(path) || [];

      return value.map(iteratee);
    }
  }, {
    key: 'mapExtra',
    value: function mapExtra(path, iteratee) {
      var value = this.get(path) || [];

      return [].concat(_toConsumableArray(value), [null]).map(iteratee);
    }
  }, {
    key: 'getErrors',
    value: function getErrors() {
      return this.state.errors || {};
    }
  }, {
    key: 'getError',
    value: function getError(name) {
      return this.getErrors()[name];
    }
  }, {
    key: 'setErrors',
    value: function setErrors(errors, callback) {
      var hadErrors = Object.getOwnPropertyNames(errors).length > 0;

      this.setState({ hadErrors: hadErrors, errors: errors }, callback);
    }
  }, {
    key: 'updateErrors',
    value: function updateErrors(errors, callback) {
      return this.setErrors(_extends({}, this.getErrors(), errors), callback);
    }
  }, {
    key: 'setError',
    value: function setError(name, error, callback) {
      return this.updateErrors(_defineProperty({}, name, error), callback);
    }
  }, {
    key: 'render',
    value: function render() {
      var $bound = this._bind$();
      var renderer = this.props.children;


      if (typeof renderer === 'function') {
        return renderer($bound);
      }

      return this.$render($bound);
    }
  }, {
    key: '_bind$',
    value: function _bind$() {
      var _this8 = this;

      var $bound = this.$.bind(this);

      Object.defineProperty($bound, 'nested', {
        value: function value(name) {
          var result = {
            attrs: _this8.get(name),
            onChange: function onChange(form) {
              return _this8.merge(name, form);
            }
          };
          return result;
        },
        enumerable: false
      });

      return $bound;
    }
  }, {
    key: '$render',
    value: function $render() {
      return null;
    }
  }, {
    key: '_validations',
    get: function get() {
      var validationz = this.props.validations || this.validations || {};

      return typeof validationz === 'function' ? validationz.call(this) : validationz;
    }
  }]);

  return Form;
}(_react.PureComponent || _react.Component);

Form.propTypes = {
  attrs: _propTypes2.default.object.isRequired,
  onChange: _propTypes2.default.func,
  clearErrorsOnChange: _propTypes2.default.bool,
  validateOnChange: _propTypes2.default.bool,
  validateOnSave: _propTypes2.default.bool,
  onRequestSave: _propTypes2.default.func,
  onValidationFailed: _propTypes2.default.func,
  validations: _propTypes2.default.object,
  children: _propTypes2.default.func
};
Form.defaultProps = {
  onChange: _utils.noop,
  clearErrorsOnChange: true,
  validateOnChange: true,
  validateOnSave: true,
  onRequestSave: _utils.noop
};
exports.default = Form;
;