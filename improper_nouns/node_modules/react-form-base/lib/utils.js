'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.noop = noop;
exports.bindState = bindState;
exports.buildFormValidator = buildFormValidator;
exports.buildHandlersCache = buildHandlersCache;

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* global WeakMap */
function noop() {}

function bindState(component) {
  var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'form';

  return {
    attrs: component.state && component.state[key] || {},
    onChange: function onChange(attrs) {
      return component.setState(_defineProperty({}, key, attrs));
    }
  };
}

function wildcard(name) {
  return name.replace(/\d+/g, '*');
}

function buildFormValidator(form) {
  function validate(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var value = options.hasOwnProperty('value') ? options.value : form.get(name);
    var validator = options['with'] || form._validations[name] || form._validations[wildcard(name)];

    if (!validator) return null;

    var error = callValidator(validator);

    if (error) {
      return validate.addError(name, error);
    }

    return null;

    function callValidator(validator) {
      if (Array.isArray(validator)) {
        return callArrayValidator(validator);
      }
      if (typeof validator === 'string') {
        return callStringValidator(validator);
      }
      if (typeof validator === 'function') {
        return validator.call(form, value);
      }
      if (validator && (typeof validator === 'undefined' ? 'undefined' : _typeof(validator)) === 'object') {
        return callObjectValidator(validator);
      }
      throw new Error('unable to use \'' + validator + '\' as validator function');
    }

    function stringToValidator(name) {
      var validator = form.constructor.validations[name];

      if (!validator) throw new Error(name + ' validation rule is not defined');

      return validator;
    }

    function callStringValidator(name, options) {
      return stringToValidator(name).call(form, value, options === true ? {} : options);
    }

    function callObjectValidator(obj) {
      for (var _name in obj) {
        var _error = callStringValidator(_name, obj[_name]);
        if (_error) return _error;
      }
    }

    function callArrayValidator(ary) {
      for (var i = 0; i < ary.length; i++) {
        var _error2 = callValidator(ary[i]);
        if (_error2) return _error2;
      }
    }
  }

  Object.assign(validate, {
    errors: {},
    clearErrors: function clearErrors() {
      this.errors = {};
    },
    addError: function addError(key, message) {
      this.errors[key] = message;
      return message;
    },
    nested: function nested(ref) {
      var nestedForm = form[ref] || form.refs[ref];
      var errors = nestedForm.performValidation();

      if (Object.getOwnPropertyNames(errors).length > 0) {
        this.addError(ref, 'invalid');
      }
    }
  });

  return validate;
}

function buildHandlersCache() {
  return new Cache();
}

var Cache = function () {
  function Cache() {
    _classCallCheck(this, Cache);

    this.store = {};
  }

  _createClass(Cache, [{
    key: 'fetch',
    value: function fetch(key, setter) {
      try {
        if (Array.isArray(key)) {
          return this.fetchComplex(key, setter);
        } else {
          return this.fetchSimple(key, setter);
        }
      } catch (_e) {
        return setter();
      }
    }
  }, {
    key: 'fetchSimple',
    value: function fetchSimple(key, setter) {
      if (!(key in this.store)) {
        this.store[key] = setter();
      }

      return this.store[key];
    }
  }, {
    key: 'fetchComplex',
    value: function fetchComplex(_ref, setter) {
      var _ref2 = _toArray(_ref),
          name = _ref2[0],
          path = _ref2.slice(1);

      name = '_' + name;
      var current = this.store[name] || (this.store[name] = new WeakMap());

      for (var i = 0; i < path.length - 1; i++) {
        if (typeof this.get(current, path[i]) === 'undefined') {
          var nextKey = path[i + 1];

          this.put(current, path[i], typeof nextKey === 'number' || typeof nextKey === 'string' || typeof nextKey === 'boolean' ? {} : new WeakMap());
        }
        current = this.get(current, path[i]);
      }
      var key = path[path.length - 1],
          cached = this.get(current, key);

      return cached || this.put(current, key, setter());
    }
  }, {
    key: 'get',
    value: function get(store, key) {
      if (store instanceof WeakMap) {
        return store.get(key);
      } else {
        return store[key];
      }
    }
  }, {
    key: 'put',
    value: function put(store, key, value) {
      if (store instanceof WeakMap) {
        store.set(key, value);
      } else {
        store[key] = value;
      }

      return value;
    }
  }]);

  return Cache;
}();